# Migration Guide: From Next.js Monolith to Go Backend + Next.js Frontend

## Overview

This document provides a step-by-step guide for migrating your SAuthenServer from a Next.js monolith (with Prisma and NextAuth.js) to a modern microservices architecture with:
- **Backend:** Go + Fiber + sqlc
- **Frontend:** Next.js 15 + Bun
- **Infrastructure:** Docker + Traefik
- **Database:** PostgreSQL (schema remains compatible)
- **Cache:** Redis
- **Auth:** PASETO tokens instead of NextAuth.js sessions

## Prerequisites

Before starting the migration, ensure you have:
- [x] Bun installed (`curl -fsSL https://bun.sh/install | bash`)
- [x] Go 1.22+ installed
- [x] Docker and Docker Compose installed
- [x] sqlc installed (`go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest`)
- [x] Database backup taken
- [x] Current application running and tested

## Phase 1: Project Structure Reorganization

### Step 1: Backup Current State
```bash
# Create a backup branch
git checkout -b backup-before-migration
git add .
git commit -m "Backup before migration to Go backend"
git push origin backup-before-migration

# Create the migration branch
git checkout -b migration-to-go-backend
```

### Step 2: Reorganize Directory Structure
The new structure is already created:
```
├── backend/                 # Go backend
│   ├── cmd/
│   │   └── server/
│   │       └── main.go
│   ├── internal/
│   │   ├── config/
│   │   ├── middleware/
│   │   ├── utils/
│   │   └── db/             # Generated by sqlc
│   ├── db/
│   │   ├── schema/         # SQL migrations
│   │   └── queries/        # SQL queries for sqlc
│   ├── Dockerfile
│   ├── go.mod
│   └── .env.example
├── frontend/                # Next.js frontend
│   ├── app/
│   ├── public/
│   ├── package.json
│   ├── Dockerfile
│   └── .env.example
├── traefik/                 # Reverse proxy config
├── docker-compose.yml
├── sqlc.yaml
├── Makefile
└── README.md
```

### Step 3: Move Existing Files
Files have been moved to the `frontend/` directory:
- ✅ `app/` → `frontend/app/`
- ✅ `next.config.js` → `frontend/next.config.js`
- ✅ `tsconfig.json` → `frontend/tsconfig.json`
- ✅ `package.json` → Updated for Bun

## Phase 2: Database Migration

### Step 1: Review Schema Compatibility
The new PostgreSQL schema is compatible with your existing Prisma schema. Key changes:
- Uses native PostgreSQL instead of Prisma
- Same table structure and relationships
- Added indexes for performance
- Uses `VARCHAR` instead of Prisma's String type

### Step 2: Generate sqlc Code
```bash
# From project root
make sqlc
```

This generates type-safe Go code in `backend/internal/db/`

### Step 3: Database Setup
```bash
# Start PostgreSQL with Docker
docker-compose up -d postgres

# Apply schema (only if starting fresh)
psql -h localhost -U postgres -d skoservice -f backend/db/schema/001_init.sql

# Or use migration tool
make migrate-up
```

### Step 4: Data Migration (if needed)
If you have existing data in Prisma format, it should work as-is since the schema is compatible.

## Phase 3: Backend Development

### Step 1: Install Go Dependencies
```bash
cd backend
go mod download
go mod tidy
```

### Step 2: Configure Environment
```bash
cp .env.example .env
# Edit .env with your actual values
```

Key environment variables:
- `DATABASE_URL`: PostgreSQL connection string
- `REDIS_URL`: Redis connection string
- `PASETO_SECRET_KEY`: 32+ character secret (generate with `openssl rand -base64 32`)
- OAuth credentials

### Step 3: Implement Authentication Service

Create `backend/internal/service/auth.go`:
```go
package service

import (
    "context"
    "time"
    "github.com/yourusername/skoservice-authenserver/backend/internal/db"
)

type AuthService struct {
    queries *db.Queries
    // Add PASETO, Redis, OAuth clients
}

func NewAuthService(queries *db.Queries) *AuthService {
    return &AuthService{
        queries: queries,
    }
}

// Implement methods:
// - Register(ctx, email, password) error
// - Login(ctx, email, password) (token string, err error)
// - ValidateToken(ctx, token string) (*UserClaims, error)
// - RefreshToken(ctx, refreshToken string) (newToken string, err error)
```

### Step 4: Run Backend
```bash
cd backend
go run cmd/server/main.go
```

Test health endpoint:
```bash
curl http://localhost:8080/health
```

## Phase 4: Frontend Migration

### Step 1: Install Frontend Dependencies
```bash
cd frontend
bun install
```

### Step 2: Update API Client

Create `frontend/lib/api.ts`:
```typescript
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add interceptors for auth token
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('auth_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default api;
```

### Step 3: Replace NextAuth.js

Remove:
```bash
bun remove next-auth @prisma/client
```

Create new auth context `frontend/contexts/AuthContext.tsx`:
```typescript
'use client';

import { createContext, useContext, useState, useEffect } from 'react';
import api from '@/lib/api';

interface User {
  id: string;
  email: string;
  name: string;
  roles: string[];
}

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Check for existing session
    const token = localStorage.getItem('auth_token');
    if (token) {
      validateToken(token);
    } else {
      setIsLoading(false);
    }
  }, []);

  const validateToken = async (token: string) => {
    try {
      const response = await api.get('/v1/auth/validate');
      setUser(response.data.data);
    } catch (error) {
      localStorage.removeItem('auth_token');
    } finally {
      setIsLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    const response = await api.post('/v1/auth/login', { email, password });
    const { token, user } = response.data.data;
    localStorage.setItem('auth_token', token);
    setUser(user);
  };

  const logout = () => {
    localStorage.removeItem('auth_token');
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
};
```

### Step 4: Run Frontend
```bash
cd frontend
bun dev
```

## Phase 5: Docker Deployment

### Step 1: Build Images
```bash
# From project root
docker-compose build
```

### Step 2: Start All Services
```bash
docker-compose up -d
```

### Step 3: Verify Services
```bash
# Check all containers are running
docker-compose ps

# Check logs
docker-compose logs -f backend
docker-compose logs -f frontend
docker-compose logs -f traefik

# Test endpoints
curl http://localhost:8080/health
curl http://localhost:3000
```

### Step 4: Access Traefik Dashboard
Open http://localhost:8081 to see Traefik dashboard

## Phase 6: Testing & Validation

### Step 1: Test Authentication Flow
1. Register a new user
2. Login with credentials
3. Test OAuth providers (Google, GitHub)
4. Verify token validation
5. Test token refresh
6. Test logout

### Step 2: Test RBAC
1. Create roles and permissions
2. Assign roles to users
3. Test permission checks
4. Verify admin access

### Step 3: Performance Testing
```bash
# Install k6
brew install k6  # macOS
# or download from https://k6.io/

# Run load test
k6 run tests/load/auth-test.js
```

### Step 4: Security Audit
- [ ] All secrets in environment variables
- [ ] HTTPS enabled in production
- [ ] CORS properly configured
- [ ] Rate limiting active
- [ ] SQL injection protected (via sqlc)
- [ ] XSS protection headers set
- [ ] CSRF protection implemented

## Phase 7: Data Migration (if needed)

If you have existing users and need to migrate:

### Step 1: Export from Prisma
```bash
# Create a migration script
node scripts/export-users.js > users-export.json
```

### Step 2: Import to New System
```bash
# Run import script
go run scripts/import-users.go users-export.json
```

### Step 3: Notify Users
If changing from session-based to token-based auth:
- Users will need to login again
- Send email notifications
- Provide migration guide for users

## Phase 8: Production Deployment

### Step 1: Proxmox LXC Setup
```bash
# On Proxmox host, create LXC container
pct create 100 local:vztmpl/ubuntu-22.04-standard_22.04-1_amd64.tar.zst \
  --hostname sauthenserver \
  --memory 4096 \
  --cores 4 \
  --net0 name=eth0,bridge=vmbr0,ip=dhcp \
  --storage local-lvm \
  --rootfs local-lvm:20

# Start container
pct start 100

# Enter container
pct enter 100

# Install Docker
curl -fsSL https://get.docker.com | sh

# Clone repository
git clone <your-repo-url>
cd SKOService-Authenserver

# Configure environment
cp backend/.env.example backend/.env
cp frontend/.env.example frontend/.env.local
# Edit with production values

# Start services
docker-compose up -d
```

### Step 2: Configure DNS
Point your domain to the LXC container IP:
```
A    auth.yourdomain.com    -> LXC_IP
A    api.yourdomain.com     -> LXC_IP
```

### Step 3: Enable HTTPS
Update `traefik/dynamic/config.yml` with your domain and Let's Encrypt will auto-provision certificates.

## Rollback Plan

If issues arise during migration:

### Quick Rollback
```bash
# Switch back to backup branch
git checkout backup-before-migration

# Restore old services
docker-compose down
npm install
npm run dev
```

### Partial Rollback
You can run both systems in parallel:
- New system on different ports
- Gradually migrate users
- Monitor both systems

## Performance Comparison

Expected improvements:
- **API Response Time:** 40-60% faster (Go vs Node.js)
- **Memory Usage:** 50-70% reduction
- **Concurrent Connections:** 3-5x increase
- **Startup Time:** 80% faster
- **Bundle Size (Frontend):** Similar with Bun optimization

## Troubleshooting

### Issue: sqlc generation fails
```bash
# Ensure sqlc is installed
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest

# Check sqlc.yaml syntax
sqlc verify
```

### Issue: Database connection fails
```bash
# Check PostgreSQL is running
docker-compose ps postgres

# Test connection
psql -h localhost -U postgres -d skoservice -c "SELECT 1;"
```

### Issue: Frontend can't reach backend
- Check `NEXT_PUBLIC_API_URL` in frontend `.env.local`
- Verify CORS settings in backend
- Check network connectivity

### Issue: OAuth not working
- Verify callback URLs match in OAuth provider settings
- Check client ID and secret are correct
- Ensure HTTPS in production (required for OAuth)

## Next Steps

After successful migration:
1. Set up monitoring (Prometheus + Grafana)
2. Configure automated backups
3. Implement CI/CD pipeline
4. Set up log aggregation (ELK stack)
5. Performance tuning
6. Load testing in production-like environment
7. Security audit
8. Documentation updates

## Support

For issues during migration:
- Check logs: `docker-compose logs -f`
- Review [Architecture Design](./architecture-design.md)
- Contact team lead
- Create GitHub issue

## Checklist

- [ ] Backup created
- [ ] Database migrated
- [ ] Backend running
- [ ] Frontend running
- [ ] Authentication working
- [ ] OAuth providers configured
- [ ] Docker setup complete
- [ ] Traefik configured
- [ ] Tests passing
- [ ] Performance validated
- [ ] Security audit done
- [ ] Documentation updated
- [ ] Production deployed
- [ ] Monitoring configured
- [ ] Team trained
